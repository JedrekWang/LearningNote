# Java并发设计的几个细节

1. volatile关键字并不保证原子性，它只保证了有序性和不重排序性
        >因此，如果有多个线程对这个关键字修饰的变量进行非原子操作会导致错误


----------------------------
2. 同步的语句是由同步域所引用的对象来保证的，而不是域本身，所以当这个域发生变化时，可能导致
域所引用的对象发生变化，而导致不同线程访问了不同的对象。
解决办法时将域修饰为final，保证了锁对象的不变性的同时也满足互斥性
ps:所以编写多线程程序时，如果不要求是可变的，就直接先把它设为final

----------------------------
3. 当把一段代码用锁来控制同步时，如
````
Lock lock = new ReentrantLock();
lock.lock();
````
一定不要忘记解锁操作，否则会导致锁泄露，最好在finally块中加入lock.unlock();这样无论如何最后
都会执行解锁操作


------------------------------------
4. synchronized(object)同步语句块的优化，在写同步语句块时在满足线程安全的前提下，有时不需要
将语句全部包起来，而是只是将需要同步的语句包起来，这样会使得程序的效率和吞吐量提高

-----------
5. 当一个方法里的子方法都是线程安全的方法时，该方法不一定为线程安全，如果不给该方法加上同步
机制，会导致异常出现

----------
6. 多重锁导致的死锁问题，当一个线程需要获取多个锁来进行操作时，可能导致死锁问题，原因是锁资源
互斥，即A线程获取1号锁，需要2号锁，B线程获取2号锁，需要1号锁
解决办法是：规定锁资源的获取顺序，即必须按照先1再2的顺序获取锁，这样就不会死锁

### ps:关于死锁，现代操作系统这本书讲的很不错，改天对这本书的死锁部分写个小结

by Jedrek
